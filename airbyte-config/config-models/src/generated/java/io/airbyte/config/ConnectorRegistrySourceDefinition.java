/*
 * Copyright (c) 2020-2025 Airbyte, Inc., all rights reserved.
 */

package io.airbyte.config;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyDescription;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonValue;
import com.fasterxml.jackson.databind.JsonNode;
import io.airbyte.protocol.models.v0.ConnectorSpecification;
import jakarta.annotation.Generated;
import java.io.Serializable;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

/**
 * ConnectorRegistrySourceDefinition
 * <p>
 * describes a source
 *
 */
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonPropertyOrder({
  "sourceDefinitionId",
  "name",
  "dockerRepository",
  "dockerImageTag",
  "documentationUrl",
  "icon",
  "iconUrl",
  "sourceType",
  "spec",
  "tombstone",
  "public",
  "custom",
  "supportLevel",
  "releaseStage",
  "releaseDate",
  "resourceRequirements",
  "protocolVersion",
  "allowedHosts",
  "suggestedStreams",
  "maxSecondsBetweenMessages",
  "releases",
  "generated",
  "packageInfo",
  "ab_internal",
  "language",
  "supportsFileTransfer",
  "connectorIPCOptions"
})
@Generated(value = "Generated by jsonSchema2Pojo")
public class ConnectorRegistrySourceDefinition implements Serializable {

  /**
   *
   * (Required)
   *
   */
  @JsonProperty("sourceDefinitionId")
  private UUID sourceDefinitionId;
  /**
   *
   * (Required)
   *
   */
  @JsonProperty("name")
  private String name;
  /**
   *
   * (Required)
   *
   */
  @JsonProperty("dockerRepository")
  private String dockerRepository;
  /**
   *
   * (Required)
   *
   */
  @JsonProperty("dockerImageTag")
  private String dockerImageTag;
  /**
   *
   * (Required)
   *
   */
  @JsonProperty("documentationUrl")
  private String documentationUrl;
  @JsonProperty("icon")
  private String icon;
  @JsonProperty("iconUrl")
  private String iconUrl;
  @JsonProperty("sourceType")
  private SourceType sourceType;
  /**
   *
   * (Required)
   *
   */
  @JsonProperty("spec")
  private ConnectorSpecification spec;
  /**
   * if false, the configuration is active. if true, then this configuration is permanently off.
   *
   */
  @JsonProperty("tombstone")
  @JsonPropertyDescription("if false, the configuration is active. if true, then this configuration is permanently off.")
  private Boolean tombstone = false;
  /**
   * true if this connector definition is available to all workspaces
   *
   */
  @JsonProperty("public")
  @JsonPropertyDescription("true if this connector definition is available to all workspaces")
  private Boolean _public = false;
  /**
   * whether this is a custom connector definition
   *
   */
  @JsonProperty("custom")
  @JsonPropertyDescription("whether this is a custom connector definition")
  private Boolean custom = false;
  /**
   * The level of support provided by Airbyte for this connector.
   *
   */
  @JsonProperty("supportLevel")
  @JsonPropertyDescription("The level of support provided by Airbyte for this connector.")
  private SupportLevel supportLevel;
  /**
   * Deprecated. Use supportLevel instead.
   *
   */
  @JsonProperty("releaseStage")
  @JsonPropertyDescription("Deprecated. Use supportLevel instead.")
  private ReleaseStage releaseStage;
  /**
   * The date when this connector was first released, in yyyy-mm-dd format.
   *
   */
  @JsonProperty("releaseDate")
  @JsonPropertyDescription("The date when this connector was first released, in yyyy-mm-dd format.")
  private String releaseDate;
  /**
   * ScopedResourceRequirements
   * <p>
   * actor or actor definition specific resource requirements
   *
   */
  @JsonProperty("resourceRequirements")
  @JsonPropertyDescription("actor or actor definition specific resource requirements")
  private ScopedResourceRequirements resourceRequirements;
  /**
   * the Airbyte Protocol version supported by the connector
   *
   */
  @JsonProperty("protocolVersion")
  @JsonPropertyDescription("the Airbyte Protocol version supported by the connector")
  private String protocolVersion;
  /**
   * AllowedHosts
   * <p>
   * A connector's allowed hosts. If present, the platform will limit communication to only hosts
   * which are listed in `AllowedHosts.hosts`.
   *
   */
  @JsonProperty("allowedHosts")
  @JsonPropertyDescription("A connector's allowed hosts.  If present, the platform will limit communication to only hosts which are listed in `AllowedHosts.hosts`.")
  private AllowedHosts allowedHosts;
  /**
   * SuggestedStreams
   * <p>
   * A source's suggested streams. These will be suggested by default for new connections using this
   * source. Otherwise, all streams will be selected. This is useful for when your source has a lot of
   * streams, but the average user will only want a subset of them synced.
   *
   */
  @JsonProperty("suggestedStreams")
  @JsonPropertyDescription("A source's suggested streams.  These will be suggested by default for new connections using this source.  Otherwise, all streams will be selected.  This is useful for when your source has a lot of streams, but the average user will only want a subset of them synced.")
  private SuggestedStreams suggestedStreams;
  /**
   * Number of seconds allowed between 2 airbyte protocol messages. The source will timeout if this
   * delay is reach
   *
   */
  @JsonProperty("maxSecondsBetweenMessages")
  @JsonPropertyDescription("Number of seconds allowed between 2 airbyte protocol messages. The source will timeout if this delay is reach")
  private Long maxSecondsBetweenMessages;
  /**
   * ConnectorReleasesSource
   * <p>
   * Releases for a source connector.
   *
   */
  @JsonProperty("releases")
  @JsonPropertyDescription("Releases for a source connector.")
  private ConnectorReleasesSource releases;
  /**
   * ConnectorRegistryEntryGeneratedFields
   * <p>
   * Optional schema for fields generated as metadata is processed
   *
   */
  @JsonProperty("generated")
  @JsonPropertyDescription("Optional schema for fields generated as metadata is processed")
  private ConnectorRegistryEntryGeneratedFields generated;
  /**
   * ConnectorPackageInfo
   * <p>
   * Information about the contents of the connector image
   *
   */
  @JsonProperty("packageInfo")
  @JsonPropertyDescription("Information about the contents of the connector image")
  private ConnectorPackageInfo packageInfo;
  /**
   * AbInternal
   * <p>
   * object that describes Airbyte internal fields
   *
   */
  @JsonProperty("ab_internal")
  @JsonPropertyDescription("object that describes Airbyte internal fields")
  private AbInternal abInternal;
  /**
   * The language that the connector is written in.
   *
   */
  @JsonProperty("language")
  @JsonPropertyDescription("The language that the connector is written in.")
  private String language;
  /**
   * flag indicating whether the file transfer mode is available for this source.
   *
   */
  @JsonProperty("supportsFileTransfer")
  @JsonPropertyDescription("flag indicating whether the file transfer mode is available for this source.")
  private Boolean supportsFileTransfer = false;
  /**
   * config containing information about connector sync architecture
   *
   */
  @JsonProperty("connectorIPCOptions")
  @JsonPropertyDescription("config containing information about connector sync architecture")
  private JsonNode connectorIPCOptions;
  @JsonIgnore
  private Map<String, Object> additionalProperties = new HashMap<String, Object>();
  private final static long serialVersionUID = -2261663407953323429L;

  /**
   *
   * (Required)
   *
   */
  @JsonProperty("sourceDefinitionId")
  public UUID getSourceDefinitionId() {
    return sourceDefinitionId;
  }

  /**
   *
   * (Required)
   *
   */
  @JsonProperty("sourceDefinitionId")
  public void setSourceDefinitionId(UUID sourceDefinitionId) {
    this.sourceDefinitionId = sourceDefinitionId;
  }

  public ConnectorRegistrySourceDefinition withSourceDefinitionId(UUID sourceDefinitionId) {
    this.sourceDefinitionId = sourceDefinitionId;
    return this;
  }

  /**
   *
   * (Required)
   *
   */
  @JsonProperty("name")
  public String getName() {
    return name;
  }

  /**
   *
   * (Required)
   *
   */
  @JsonProperty("name")
  public void setName(String name) {
    this.name = name;
  }

  public ConnectorRegistrySourceDefinition withName(String name) {
    this.name = name;
    return this;
  }

  /**
   *
   * (Required)
   *
   */
  @JsonProperty("dockerRepository")
  public String getDockerRepository() {
    return dockerRepository;
  }

  /**
   *
   * (Required)
   *
   */
  @JsonProperty("dockerRepository")
  public void setDockerRepository(String dockerRepository) {
    this.dockerRepository = dockerRepository;
  }

  public ConnectorRegistrySourceDefinition withDockerRepository(String dockerRepository) {
    this.dockerRepository = dockerRepository;
    return this;
  }

  /**
   *
   * (Required)
   *
   */
  @JsonProperty("dockerImageTag")
  public String getDockerImageTag() {
    return dockerImageTag;
  }

  /**
   *
   * (Required)
   *
   */
  @JsonProperty("dockerImageTag")
  public void setDockerImageTag(String dockerImageTag) {
    this.dockerImageTag = dockerImageTag;
  }

  public ConnectorRegistrySourceDefinition withDockerImageTag(String dockerImageTag) {
    this.dockerImageTag = dockerImageTag;
    return this;
  }

  /**
   *
   * (Required)
   *
   */
  @JsonProperty("documentationUrl")
  public String getDocumentationUrl() {
    return documentationUrl;
  }

  /**
   *
   * (Required)
   *
   */
  @JsonProperty("documentationUrl")
  public void setDocumentationUrl(String documentationUrl) {
    this.documentationUrl = documentationUrl;
  }

  public ConnectorRegistrySourceDefinition withDocumentationUrl(String documentationUrl) {
    this.documentationUrl = documentationUrl;
    return this;
  }

  @JsonProperty("icon")
  public String getIcon() {
    return icon;
  }

  @JsonProperty("icon")
  public void setIcon(String icon) {
    this.icon = icon;
  }

  public ConnectorRegistrySourceDefinition withIcon(String icon) {
    this.icon = icon;
    return this;
  }

  @JsonProperty("iconUrl")
  public String getIconUrl() {
    return iconUrl;
  }

  @JsonProperty("iconUrl")
  public void setIconUrl(String iconUrl) {
    this.iconUrl = iconUrl;
  }

  public ConnectorRegistrySourceDefinition withIconUrl(String iconUrl) {
    this.iconUrl = iconUrl;
    return this;
  }

  @JsonProperty("sourceType")
  public SourceType getSourceType() {
    return sourceType;
  }

  @JsonProperty("sourceType")
  public void setSourceType(SourceType sourceType) {
    this.sourceType = sourceType;
  }

  public ConnectorRegistrySourceDefinition withSourceType(SourceType sourceType) {
    this.sourceType = sourceType;
    return this;
  }

  /**
   *
   * (Required)
   *
   */
  @JsonProperty("spec")
  public ConnectorSpecification getSpec() {
    return spec;
  }

  /**
   *
   * (Required)
   *
   */
  @JsonProperty("spec")
  public void setSpec(ConnectorSpecification spec) {
    this.spec = spec;
  }

  public ConnectorRegistrySourceDefinition withSpec(ConnectorSpecification spec) {
    this.spec = spec;
    return this;
  }

  /**
   * if false, the configuration is active. if true, then this configuration is permanently off.
   *
   */
  @JsonProperty("tombstone")
  public Boolean getTombstone() {
    return tombstone;
  }

  /**
   * if false, the configuration is active. if true, then this configuration is permanently off.
   *
   */
  @JsonProperty("tombstone")
  public void setTombstone(Boolean tombstone) {
    this.tombstone = tombstone;
  }

  public ConnectorRegistrySourceDefinition withTombstone(Boolean tombstone) {
    this.tombstone = tombstone;
    return this;
  }

  /**
   * true if this connector definition is available to all workspaces
   *
   */
  @JsonProperty("public")
  public Boolean getPublic() {
    return _public;
  }

  /**
   * true if this connector definition is available to all workspaces
   *
   */
  @JsonProperty("public")
  public void setPublic(Boolean _public) {
    this._public = _public;
  }

  public ConnectorRegistrySourceDefinition withPublic(Boolean _public) {
    this._public = _public;
    return this;
  }

  /**
   * whether this is a custom connector definition
   *
   */
  @JsonProperty("custom")
  public Boolean getCustom() {
    return custom;
  }

  /**
   * whether this is a custom connector definition
   *
   */
  @JsonProperty("custom")
  public void setCustom(Boolean custom) {
    this.custom = custom;
  }

  public ConnectorRegistrySourceDefinition withCustom(Boolean custom) {
    this.custom = custom;
    return this;
  }

  /**
   * The level of support provided by Airbyte for this connector.
   *
   */
  @JsonProperty("supportLevel")
  public SupportLevel getSupportLevel() {
    return supportLevel;
  }

  /**
   * The level of support provided by Airbyte for this connector.
   *
   */
  @JsonProperty("supportLevel")
  public void setSupportLevel(SupportLevel supportLevel) {
    this.supportLevel = supportLevel;
  }

  public ConnectorRegistrySourceDefinition withSupportLevel(SupportLevel supportLevel) {
    this.supportLevel = supportLevel;
    return this;
  }

  /**
   * Deprecated. Use supportLevel instead.
   *
   */
  @JsonProperty("releaseStage")
  public ReleaseStage getReleaseStage() {
    return releaseStage;
  }

  /**
   * Deprecated. Use supportLevel instead.
   *
   */
  @JsonProperty("releaseStage")
  public void setReleaseStage(ReleaseStage releaseStage) {
    this.releaseStage = releaseStage;
  }

  public ConnectorRegistrySourceDefinition withReleaseStage(ReleaseStage releaseStage) {
    this.releaseStage = releaseStage;
    return this;
  }

  /**
   * The date when this connector was first released, in yyyy-mm-dd format.
   *
   */
  @JsonProperty("releaseDate")
  public String getReleaseDate() {
    return releaseDate;
  }

  /**
   * The date when this connector was first released, in yyyy-mm-dd format.
   *
   */
  @JsonProperty("releaseDate")
  public void setReleaseDate(String releaseDate) {
    this.releaseDate = releaseDate;
  }

  public ConnectorRegistrySourceDefinition withReleaseDate(String releaseDate) {
    this.releaseDate = releaseDate;
    return this;
  }

  /**
   * ScopedResourceRequirements
   * <p>
   * actor or actor definition specific resource requirements
   *
   */
  @JsonProperty("resourceRequirements")
  public ScopedResourceRequirements getResourceRequirements() {
    return resourceRequirements;
  }

  /**
   * ScopedResourceRequirements
   * <p>
   * actor or actor definition specific resource requirements
   *
   */
  @JsonProperty("resourceRequirements")
  public void setResourceRequirements(ScopedResourceRequirements resourceRequirements) {
    this.resourceRequirements = resourceRequirements;
  }

  public ConnectorRegistrySourceDefinition withResourceRequirements(ScopedResourceRequirements resourceRequirements) {
    this.resourceRequirements = resourceRequirements;
    return this;
  }

  /**
   * the Airbyte Protocol version supported by the connector
   *
   */
  @JsonProperty("protocolVersion")
  public String getProtocolVersion() {
    return protocolVersion;
  }

  /**
   * the Airbyte Protocol version supported by the connector
   *
   */
  @JsonProperty("protocolVersion")
  public void setProtocolVersion(String protocolVersion) {
    this.protocolVersion = protocolVersion;
  }

  public ConnectorRegistrySourceDefinition withProtocolVersion(String protocolVersion) {
    this.protocolVersion = protocolVersion;
    return this;
  }

  /**
   * AllowedHosts
   * <p>
   * A connector's allowed hosts. If present, the platform will limit communication to only hosts
   * which are listed in `AllowedHosts.hosts`.
   *
   */
  @JsonProperty("allowedHosts")
  public AllowedHosts getAllowedHosts() {
    return allowedHosts;
  }

  /**
   * AllowedHosts
   * <p>
   * A connector's allowed hosts. If present, the platform will limit communication to only hosts
   * which are listed in `AllowedHosts.hosts`.
   *
   */
  @JsonProperty("allowedHosts")
  public void setAllowedHosts(AllowedHosts allowedHosts) {
    this.allowedHosts = allowedHosts;
  }

  public ConnectorRegistrySourceDefinition withAllowedHosts(AllowedHosts allowedHosts) {
    this.allowedHosts = allowedHosts;
    return this;
  }

  /**
   * SuggestedStreams
   * <p>
   * A source's suggested streams. These will be suggested by default for new connections using this
   * source. Otherwise, all streams will be selected. This is useful for when your source has a lot of
   * streams, but the average user will only want a subset of them synced.
   *
   */
  @JsonProperty("suggestedStreams")
  public SuggestedStreams getSuggestedStreams() {
    return suggestedStreams;
  }

  /**
   * SuggestedStreams
   * <p>
   * A source's suggested streams. These will be suggested by default for new connections using this
   * source. Otherwise, all streams will be selected. This is useful for when your source has a lot of
   * streams, but the average user will only want a subset of them synced.
   *
   */
  @JsonProperty("suggestedStreams")
  public void setSuggestedStreams(SuggestedStreams suggestedStreams) {
    this.suggestedStreams = suggestedStreams;
  }

  public ConnectorRegistrySourceDefinition withSuggestedStreams(SuggestedStreams suggestedStreams) {
    this.suggestedStreams = suggestedStreams;
    return this;
  }

  /**
   * Number of seconds allowed between 2 airbyte protocol messages. The source will timeout if this
   * delay is reach
   *
   */
  @JsonProperty("maxSecondsBetweenMessages")
  public Long getMaxSecondsBetweenMessages() {
    return maxSecondsBetweenMessages;
  }

  /**
   * Number of seconds allowed between 2 airbyte protocol messages. The source will timeout if this
   * delay is reach
   *
   */
  @JsonProperty("maxSecondsBetweenMessages")
  public void setMaxSecondsBetweenMessages(Long maxSecondsBetweenMessages) {
    this.maxSecondsBetweenMessages = maxSecondsBetweenMessages;
  }

  public ConnectorRegistrySourceDefinition withMaxSecondsBetweenMessages(Long maxSecondsBetweenMessages) {
    this.maxSecondsBetweenMessages = maxSecondsBetweenMessages;
    return this;
  }

  /**
   * ConnectorReleasesSource
   * <p>
   * Releases for a source connector.
   *
   */
  @JsonProperty("releases")
  public ConnectorReleasesSource getReleases() {
    return releases;
  }

  /**
   * ConnectorReleasesSource
   * <p>
   * Releases for a source connector.
   *
   */
  @JsonProperty("releases")
  public void setReleases(ConnectorReleasesSource releases) {
    this.releases = releases;
  }

  public ConnectorRegistrySourceDefinition withReleases(ConnectorReleasesSource releases) {
    this.releases = releases;
    return this;
  }

  /**
   * ConnectorRegistryEntryGeneratedFields
   * <p>
   * Optional schema for fields generated as metadata is processed
   *
   */
  @JsonProperty("generated")
  public ConnectorRegistryEntryGeneratedFields getGenerated() {
    return generated;
  }

  /**
   * ConnectorRegistryEntryGeneratedFields
   * <p>
   * Optional schema for fields generated as metadata is processed
   *
   */
  @JsonProperty("generated")
  public void setGenerated(ConnectorRegistryEntryGeneratedFields generated) {
    this.generated = generated;
  }

  public ConnectorRegistrySourceDefinition withGenerated(ConnectorRegistryEntryGeneratedFields generated) {
    this.generated = generated;
    return this;
  }

  /**
   * ConnectorPackageInfo
   * <p>
   * Information about the contents of the connector image
   *
   */
  @JsonProperty("packageInfo")
  public ConnectorPackageInfo getPackageInfo() {
    return packageInfo;
  }

  /**
   * ConnectorPackageInfo
   * <p>
   * Information about the contents of the connector image
   *
   */
  @JsonProperty("packageInfo")
  public void setPackageInfo(ConnectorPackageInfo packageInfo) {
    this.packageInfo = packageInfo;
  }

  public ConnectorRegistrySourceDefinition withPackageInfo(ConnectorPackageInfo packageInfo) {
    this.packageInfo = packageInfo;
    return this;
  }

  /**
   * AbInternal
   * <p>
   * object that describes Airbyte internal fields
   *
   */
  @JsonProperty("ab_internal")
  public AbInternal getAbInternal() {
    return abInternal;
  }

  /**
   * AbInternal
   * <p>
   * object that describes Airbyte internal fields
   *
   */
  @JsonProperty("ab_internal")
  public void setAbInternal(AbInternal abInternal) {
    this.abInternal = abInternal;
  }

  public ConnectorRegistrySourceDefinition withAbInternal(AbInternal abInternal) {
    this.abInternal = abInternal;
    return this;
  }

  /**
   * The language that the connector is written in.
   *
   */
  @JsonProperty("language")
  public String getLanguage() {
    return language;
  }

  /**
   * The language that the connector is written in.
   *
   */
  @JsonProperty("language")
  public void setLanguage(String language) {
    this.language = language;
  }

  public ConnectorRegistrySourceDefinition withLanguage(String language) {
    this.language = language;
    return this;
  }

  /**
   * flag indicating whether the file transfer mode is available for this source.
   *
   */
  @JsonProperty("supportsFileTransfer")
  public Boolean getSupportsFileTransfer() {
    return supportsFileTransfer;
  }

  /**
   * flag indicating whether the file transfer mode is available for this source.
   *
   */
  @JsonProperty("supportsFileTransfer")
  public void setSupportsFileTransfer(Boolean supportsFileTransfer) {
    this.supportsFileTransfer = supportsFileTransfer;
  }

  public ConnectorRegistrySourceDefinition withSupportsFileTransfer(Boolean supportsFileTransfer) {
    this.supportsFileTransfer = supportsFileTransfer;
    return this;
  }

  /**
   * config containing information about connector sync architecture
   *
   */
  @JsonProperty("connectorIPCOptions")
  public JsonNode getConnectorIPCOptions() {
    return connectorIPCOptions;
  }

  /**
   * config containing information about connector sync architecture
   *
   */
  @JsonProperty("connectorIPCOptions")
  public void setConnectorIPCOptions(JsonNode connectorIPCOptions) {
    this.connectorIPCOptions = connectorIPCOptions;
  }

  public ConnectorRegistrySourceDefinition withConnectorIPCOptions(JsonNode connectorIPCOptions) {
    this.connectorIPCOptions = connectorIPCOptions;
    return this;
  }

  @JsonAnyGetter
  public Map<String, Object> getAdditionalProperties() {
    return this.additionalProperties;
  }

  @JsonAnySetter
  public void setAdditionalProperty(String name, Object value) {
    this.additionalProperties.put(name, value);
  }

  public ConnectorRegistrySourceDefinition withAdditionalProperty(String name, Object value) {
    this.additionalProperties.put(name, value);
    return this;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append(ConnectorRegistrySourceDefinition.class.getName()).append('@').append(Integer.toHexString(System.identityHashCode(this))).append('[');
    sb.append("sourceDefinitionId");
    sb.append('=');
    sb.append(((this.sourceDefinitionId == null) ? "<null>" : this.sourceDefinitionId));
    sb.append(',');
    sb.append("name");
    sb.append('=');
    sb.append(((this.name == null) ? "<null>" : this.name));
    sb.append(',');
    sb.append("dockerRepository");
    sb.append('=');
    sb.append(((this.dockerRepository == null) ? "<null>" : this.dockerRepository));
    sb.append(',');
    sb.append("dockerImageTag");
    sb.append('=');
    sb.append(((this.dockerImageTag == null) ? "<null>" : this.dockerImageTag));
    sb.append(',');
    sb.append("documentationUrl");
    sb.append('=');
    sb.append(((this.documentationUrl == null) ? "<null>" : this.documentationUrl));
    sb.append(',');
    sb.append("icon");
    sb.append('=');
    sb.append(((this.icon == null) ? "<null>" : this.icon));
    sb.append(',');
    sb.append("iconUrl");
    sb.append('=');
    sb.append(((this.iconUrl == null) ? "<null>" : this.iconUrl));
    sb.append(',');
    sb.append("sourceType");
    sb.append('=');
    sb.append(((this.sourceType == null) ? "<null>" : this.sourceType));
    sb.append(',');
    sb.append("spec");
    sb.append('=');
    sb.append(((this.spec == null) ? "<null>" : this.spec));
    sb.append(',');
    sb.append("tombstone");
    sb.append('=');
    sb.append(((this.tombstone == null) ? "<null>" : this.tombstone));
    sb.append(',');
    sb.append("_public");
    sb.append('=');
    sb.append(((this._public == null) ? "<null>" : this._public));
    sb.append(',');
    sb.append("custom");
    sb.append('=');
    sb.append(((this.custom == null) ? "<null>" : this.custom));
    sb.append(',');
    sb.append("supportLevel");
    sb.append('=');
    sb.append(((this.supportLevel == null) ? "<null>" : this.supportLevel));
    sb.append(',');
    sb.append("releaseStage");
    sb.append('=');
    sb.append(((this.releaseStage == null) ? "<null>" : this.releaseStage));
    sb.append(',');
    sb.append("releaseDate");
    sb.append('=');
    sb.append(((this.releaseDate == null) ? "<null>" : this.releaseDate));
    sb.append(',');
    sb.append("resourceRequirements");
    sb.append('=');
    sb.append(((this.resourceRequirements == null) ? "<null>" : this.resourceRequirements));
    sb.append(',');
    sb.append("protocolVersion");
    sb.append('=');
    sb.append(((this.protocolVersion == null) ? "<null>" : this.protocolVersion));
    sb.append(',');
    sb.append("allowedHosts");
    sb.append('=');
    sb.append(((this.allowedHosts == null) ? "<null>" : this.allowedHosts));
    sb.append(',');
    sb.append("suggestedStreams");
    sb.append('=');
    sb.append(((this.suggestedStreams == null) ? "<null>" : this.suggestedStreams));
    sb.append(',');
    sb.append("maxSecondsBetweenMessages");
    sb.append('=');
    sb.append(((this.maxSecondsBetweenMessages == null) ? "<null>" : this.maxSecondsBetweenMessages));
    sb.append(',');
    sb.append("releases");
    sb.append('=');
    sb.append(((this.releases == null) ? "<null>" : this.releases));
    sb.append(',');
    sb.append("generated");
    sb.append('=');
    sb.append(((this.generated == null) ? "<null>" : this.generated));
    sb.append(',');
    sb.append("packageInfo");
    sb.append('=');
    sb.append(((this.packageInfo == null) ? "<null>" : this.packageInfo));
    sb.append(',');
    sb.append("abInternal");
    sb.append('=');
    sb.append(((this.abInternal == null) ? "<null>" : this.abInternal));
    sb.append(',');
    sb.append("language");
    sb.append('=');
    sb.append(((this.language == null) ? "<null>" : this.language));
    sb.append(',');
    sb.append("supportsFileTransfer");
    sb.append('=');
    sb.append(((this.supportsFileTransfer == null) ? "<null>" : this.supportsFileTransfer));
    sb.append(',');
    sb.append("connectorIPCOptions");
    sb.append('=');
    sb.append(((this.connectorIPCOptions == null) ? "<null>" : this.connectorIPCOptions));
    sb.append(',');
    sb.append("additionalProperties");
    sb.append('=');
    sb.append(((this.additionalProperties == null) ? "<null>" : this.additionalProperties));
    sb.append(',');
    if (sb.charAt((sb.length() - 1)) == ',') {
      sb.setCharAt((sb.length() - 1), ']');
    } else {
      sb.append(']');
    }
    return sb.toString();
  }

  @Override
  public int hashCode() {
    int result = 1;
    result = ((result * 31) + ((this.allowedHosts == null) ? 0 : this.allowedHosts.hashCode()));
    result = ((result * 31) + ((this.documentationUrl == null) ? 0 : this.documentationUrl.hashCode()));
    result = ((result * 31) + ((this.releaseStage == null) ? 0 : this.releaseStage.hashCode()));
    result = ((result * 31) + ((this.icon == null) ? 0 : this.icon.hashCode()));
    result = ((result * 31) + ((this.language == null) ? 0 : this.language.hashCode()));
    result = ((result * 31) + ((this.spec == null) ? 0 : this.spec.hashCode()));
    result = ((result * 31) + ((this.suggestedStreams == null) ? 0 : this.suggestedStreams.hashCode()));
    result = ((result * 31) + ((this.generated == null) ? 0 : this.generated.hashCode()));
    result = ((result * 31) + ((this.protocolVersion == null) ? 0 : this.protocolVersion.hashCode()));
    result = ((result * 31) + ((this.iconUrl == null) ? 0 : this.iconUrl.hashCode()));
    result = ((result * 31) + ((this.abInternal == null) ? 0 : this.abInternal.hashCode()));
    result = ((result * 31) + ((this.tombstone == null) ? 0 : this.tombstone.hashCode()));
    result = ((result * 31) + ((this._public == null) ? 0 : this._public.hashCode()));
    result = ((result * 31) + ((this.releaseDate == null) ? 0 : this.releaseDate.hashCode()));
    result = ((result * 31) + ((this.dockerRepository == null) ? 0 : this.dockerRepository.hashCode()));
    result = ((result * 31) + ((this.custom == null) ? 0 : this.custom.hashCode()));
    result = ((result * 31) + ((this.sourceDefinitionId == null) ? 0 : this.sourceDefinitionId.hashCode()));
    result = ((result * 31) + ((this.supportLevel == null) ? 0 : this.supportLevel.hashCode()));
    result = ((result * 31) + ((this.maxSecondsBetweenMessages == null) ? 0 : this.maxSecondsBetweenMessages.hashCode()));
    result = ((result * 31) + ((this.connectorIPCOptions == null) ? 0 : this.connectorIPCOptions.hashCode()));
    result = ((result * 31) + ((this.releases == null) ? 0 : this.releases.hashCode()));
    result = ((result * 31) + ((this.resourceRequirements == null) ? 0 : this.resourceRequirements.hashCode()));
    result = ((result * 31) + ((this.dockerImageTag == null) ? 0 : this.dockerImageTag.hashCode()));
    result = ((result * 31) + ((this.sourceType == null) ? 0 : this.sourceType.hashCode()));
    result = ((result * 31) + ((this.name == null) ? 0 : this.name.hashCode()));
    result = ((result * 31) + ((this.additionalProperties == null) ? 0 : this.additionalProperties.hashCode()));
    result = ((result * 31) + ((this.packageInfo == null) ? 0 : this.packageInfo.hashCode()));
    result = ((result * 31) + ((this.supportsFileTransfer == null) ? 0 : this.supportsFileTransfer.hashCode()));
    return result;
  }

  @Override
  public boolean equals(Object other) {
    if (other == this) {
      return true;
    }
    if ((other instanceof ConnectorRegistrySourceDefinition) == false) {
      return false;
    }
    ConnectorRegistrySourceDefinition rhs = ((ConnectorRegistrySourceDefinition) other);
    return (((((((((((((((((((((((((((((this.allowedHosts == rhs.allowedHosts)
        || ((this.allowedHosts != null) && this.allowedHosts.equals(rhs.allowedHosts)))
        && ((this.documentationUrl == rhs.documentationUrl)
            || ((this.documentationUrl != null) && this.documentationUrl.equals(rhs.documentationUrl))))
        && ((this.releaseStage == rhs.releaseStage) || ((this.releaseStage != null) && this.releaseStage.equals(rhs.releaseStage))))
        && ((this.icon == rhs.icon) || ((this.icon != null) && this.icon.equals(rhs.icon))))
        && ((this.language == rhs.language) || ((this.language != null) && this.language.equals(rhs.language))))
        && ((this.spec == rhs.spec) || ((this.spec != null) && this.spec.equals(rhs.spec))))
        && ((this.suggestedStreams == rhs.suggestedStreams)
            || ((this.suggestedStreams != null) && this.suggestedStreams.equals(rhs.suggestedStreams))))
        && ((this.generated == rhs.generated) || ((this.generated != null) && this.generated.equals(rhs.generated))))
        && ((this.protocolVersion == rhs.protocolVersion) || ((this.protocolVersion != null) && this.protocolVersion.equals(rhs.protocolVersion))))
        && ((this.iconUrl == rhs.iconUrl) || ((this.iconUrl != null) && this.iconUrl.equals(rhs.iconUrl))))
        && ((this.abInternal == rhs.abInternal) || ((this.abInternal != null) && this.abInternal.equals(rhs.abInternal))))
        && ((this.tombstone == rhs.tombstone) || ((this.tombstone != null) && this.tombstone.equals(rhs.tombstone))))
        && ((this._public == rhs._public) || ((this._public != null) && this._public.equals(rhs._public))))
        && ((this.releaseDate == rhs.releaseDate) || ((this.releaseDate != null) && this.releaseDate.equals(rhs.releaseDate))))
        && ((this.dockerRepository == rhs.dockerRepository)
            || ((this.dockerRepository != null) && this.dockerRepository.equals(rhs.dockerRepository))))
        && ((this.custom == rhs.custom) || ((this.custom != null) && this.custom.equals(rhs.custom))))
        && ((this.sourceDefinitionId == rhs.sourceDefinitionId)
            || ((this.sourceDefinitionId != null) && this.sourceDefinitionId.equals(rhs.sourceDefinitionId))))
        && ((this.supportLevel == rhs.supportLevel) || ((this.supportLevel != null) && this.supportLevel.equals(rhs.supportLevel))))
        && ((this.maxSecondsBetweenMessages == rhs.maxSecondsBetweenMessages)
            || ((this.maxSecondsBetweenMessages != null) && this.maxSecondsBetweenMessages.equals(rhs.maxSecondsBetweenMessages))))
        && ((this.connectorIPCOptions == rhs.connectorIPCOptions)
            || ((this.connectorIPCOptions != null) && this.connectorIPCOptions.equals(rhs.connectorIPCOptions))))
        && ((this.releases == rhs.releases) || ((this.releases != null) && this.releases.equals(rhs.releases))))
        && ((this.resourceRequirements == rhs.resourceRequirements)
            || ((this.resourceRequirements != null) && this.resourceRequirements.equals(rhs.resourceRequirements))))
        && ((this.dockerImageTag == rhs.dockerImageTag) || ((this.dockerImageTag != null) && this.dockerImageTag.equals(rhs.dockerImageTag))))
        && ((this.sourceType == rhs.sourceType) || ((this.sourceType != null) && this.sourceType.equals(rhs.sourceType))))
        && ((this.name == rhs.name) || ((this.name != null) && this.name.equals(rhs.name))))
        && ((this.additionalProperties == rhs.additionalProperties)
            || ((this.additionalProperties != null) && this.additionalProperties.equals(rhs.additionalProperties))))
        && ((this.packageInfo == rhs.packageInfo) || ((this.packageInfo != null) && this.packageInfo.equals(rhs.packageInfo))))
        && ((this.supportsFileTransfer == rhs.supportsFileTransfer)
            || ((this.supportsFileTransfer != null) && this.supportsFileTransfer.equals(rhs.supportsFileTransfer))));
  }

  public enum SourceType {

    API("api"),
    FILE("file"),
    DATABASE("database"),
    CUSTOM("custom");

    private final String value;
    private final static Map<String, SourceType> CONSTANTS = new HashMap<String, SourceType>();

    static {
      for (SourceType c : values()) {
        CONSTANTS.put(c.value, c);
      }
    }

    private SourceType(String value) {
      this.value = value;
    }

    @Override
    public String toString() {
      return this.value;
    }

    @JsonValue
    public String value() {
      return this.value;
    }

    @JsonCreator
    public static SourceType fromValue(String value) {
      SourceType constant = CONSTANTS.get(value);
      if (constant == null) {
        throw new IllegalArgumentException(value);
      } else {
        return constant;
      }
    }

  }

}
