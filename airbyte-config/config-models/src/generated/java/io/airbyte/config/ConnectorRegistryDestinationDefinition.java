/*
 * Copyright (c) 2020-2025 Airbyte, Inc., all rights reserved.
 */

package io.airbyte.config;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyDescription;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.databind.JsonNode;
import io.airbyte.protocol.models.v0.ConnectorSpecification;
import jakarta.annotation.Generated;
import java.io.Serializable;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

/**
 * ConnectorRegistryDestinationDefinition
 * <p>
 * describes a destination
 *
 */
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonPropertyOrder({
  "destinationDefinitionId",
  "name",
  "dockerRepository",
  "dockerImageTag",
  "documentationUrl",
  "icon",
  "iconUrl",
  "spec",
  "tombstone",
  "public",
  "custom",
  "supportLevel",
  "releaseStage",
  "releaseDate",
  "resourceRequirements",
  "protocolVersion",
  "allowedHosts",
  "releases",
  "supportsRefreshes",
  "generated",
  "packageInfo",
  "ab_internal",
  "language",
  "supportsFileTransfer",
  "supportsDataActivation",
  "connectorIPCOptions"
})
@Generated(value = "Generated by jsonSchema2Pojo")
public class ConnectorRegistryDestinationDefinition implements Serializable {

  /**
   *
   * (Required)
   *
   */
  @JsonProperty("destinationDefinitionId")
  private UUID destinationDefinitionId;
  /**
   *
   * (Required)
   *
   */
  @JsonProperty("name")
  private String name;
  /**
   *
   * (Required)
   *
   */
  @JsonProperty("dockerRepository")
  private String dockerRepository;
  /**
   *
   * (Required)
   *
   */
  @JsonProperty("dockerImageTag")
  private String dockerImageTag;
  /**
   *
   * (Required)
   *
   */
  @JsonProperty("documentationUrl")
  private String documentationUrl;
  @JsonProperty("icon")
  private String icon;
  @JsonProperty("iconUrl")
  private String iconUrl;
  /**
   *
   * (Required)
   *
   */
  @JsonProperty("spec")
  private ConnectorSpecification spec;
  /**
   * if false, the configuration is active. if true, then this configuration is permanently off.
   *
   */
  @JsonProperty("tombstone")
  @JsonPropertyDescription("if false, the configuration is active. if true, then this configuration is permanently off.")
  private Boolean tombstone = false;
  /**
   * true if this connector definition is available to all workspaces
   *
   */
  @JsonProperty("public")
  @JsonPropertyDescription("true if this connector definition is available to all workspaces")
  private Boolean _public = false;
  /**
   * whether this is a custom connector definition
   *
   */
  @JsonProperty("custom")
  @JsonPropertyDescription("whether this is a custom connector definition")
  private Boolean custom = false;
  /**
   * The level of support provided by Airbyte for this connector.
   *
   */
  @JsonProperty("supportLevel")
  @JsonPropertyDescription("The level of support provided by Airbyte for this connector.")
  private SupportLevel supportLevel;
  /**
   * Deprecated. Use supportLevel instead.
   *
   */
  @JsonProperty("releaseStage")
  @JsonPropertyDescription("Deprecated. Use supportLevel instead.")
  private ReleaseStage releaseStage;
  /**
   * The date when this connector was first released, in yyyy-mm-dd format.
   *
   */
  @JsonProperty("releaseDate")
  @JsonPropertyDescription("The date when this connector was first released, in yyyy-mm-dd format.")
  private String releaseDate;
  /**
   * ScopedResourceRequirements
   * <p>
   * actor or actor definition specific resource requirements
   *
   */
  @JsonProperty("resourceRequirements")
  @JsonPropertyDescription("actor or actor definition specific resource requirements")
  private ScopedResourceRequirements resourceRequirements;
  /**
   * the Airbyte Protocol version supported by the connector
   *
   */
  @JsonProperty("protocolVersion")
  @JsonPropertyDescription("the Airbyte Protocol version supported by the connector")
  private String protocolVersion;
  /**
   * AllowedHosts
   * <p>
   * A connector's allowed hosts. If present, the platform will limit communication to only hosts
   * which are listed in `AllowedHosts.hosts`.
   *
   */
  @JsonProperty("allowedHosts")
  @JsonPropertyDescription("A connector's allowed hosts.  If present, the platform will limit communication to only hosts which are listed in `AllowedHosts.hosts`.")
  private AllowedHosts allowedHosts;
  /**
   * ConnectorReleasesDestination
   * <p>
   * Releases for a destination connector.
   *
   */
  @JsonProperty("releases")
  @JsonPropertyDescription("Releases for a destination connector.")
  private ConnectorReleasesDestination releases;
  /**
   * an optional flag indicating whether the refresh operation is available for this destination.
   *
   */
  @JsonProperty("supportsRefreshes")
  @JsonPropertyDescription("an optional flag indicating whether the refresh operation is available for this destination.")
  private Boolean supportsRefreshes;
  /**
   * ConnectorRegistryEntryGeneratedFields
   * <p>
   * Optional schema for fields generated as metadata is processed
   *
   */
  @JsonProperty("generated")
  @JsonPropertyDescription("Optional schema for fields generated as metadata is processed")
  private ConnectorRegistryEntryGeneratedFields generated;
  /**
   * ConnectorPackageInfo
   * <p>
   * Information about the contents of the connector image
   *
   */
  @JsonProperty("packageInfo")
  @JsonPropertyDescription("Information about the contents of the connector image")
  private ConnectorPackageInfo packageInfo;
  /**
   * AbInternal
   * <p>
   * object that describes Airbyte internal fields
   *
   */
  @JsonProperty("ab_internal")
  @JsonPropertyDescription("object that describes Airbyte internal fields")
  private AbInternal abInternal;
  /**
   * The language that the connector is written in.
   *
   */
  @JsonProperty("language")
  @JsonPropertyDescription("The language that the connector is written in.")
  private String language;
  /**
   * flag indicating whether the file transfer mode is available for this destination.
   *
   */
  @JsonProperty("supportsFileTransfer")
  @JsonPropertyDescription("flag indicating whether the file transfer mode is available for this destination.")
  private Boolean supportsFileTransfer = false;
  /**
   * flag indicating whether the connection configuration should align with the data activation
   * paradigm.
   *
   */
  @JsonProperty("supportsDataActivation")
  @JsonPropertyDescription("flag indicating whether the connection configuration should align with the data activation paradigm.")
  private Boolean supportsDataActivation = false;
  /**
   * config containing information about connector sync architecture
   *
   */
  @JsonProperty("connectorIPCOptions")
  @JsonPropertyDescription("config containing information about connector sync architecture")
  private JsonNode connectorIPCOptions;
  @JsonIgnore
  private Map<String, Object> additionalProperties = new HashMap<String, Object>();
  private final static long serialVersionUID = 7843701781087142150L;

  /**
   *
   * (Required)
   *
   */
  @JsonProperty("destinationDefinitionId")
  public UUID getDestinationDefinitionId() {
    return destinationDefinitionId;
  }

  /**
   *
   * (Required)
   *
   */
  @JsonProperty("destinationDefinitionId")
  public void setDestinationDefinitionId(UUID destinationDefinitionId) {
    this.destinationDefinitionId = destinationDefinitionId;
  }

  public ConnectorRegistryDestinationDefinition withDestinationDefinitionId(UUID destinationDefinitionId) {
    this.destinationDefinitionId = destinationDefinitionId;
    return this;
  }

  /**
   *
   * (Required)
   *
   */
  @JsonProperty("name")
  public String getName() {
    return name;
  }

  /**
   *
   * (Required)
   *
   */
  @JsonProperty("name")
  public void setName(String name) {
    this.name = name;
  }

  public ConnectorRegistryDestinationDefinition withName(String name) {
    this.name = name;
    return this;
  }

  /**
   *
   * (Required)
   *
   */
  @JsonProperty("dockerRepository")
  public String getDockerRepository() {
    return dockerRepository;
  }

  /**
   *
   * (Required)
   *
   */
  @JsonProperty("dockerRepository")
  public void setDockerRepository(String dockerRepository) {
    this.dockerRepository = dockerRepository;
  }

  public ConnectorRegistryDestinationDefinition withDockerRepository(String dockerRepository) {
    this.dockerRepository = dockerRepository;
    return this;
  }

  /**
   *
   * (Required)
   *
   */
  @JsonProperty("dockerImageTag")
  public String getDockerImageTag() {
    return dockerImageTag;
  }

  /**
   *
   * (Required)
   *
   */
  @JsonProperty("dockerImageTag")
  public void setDockerImageTag(String dockerImageTag) {
    this.dockerImageTag = dockerImageTag;
  }

  public ConnectorRegistryDestinationDefinition withDockerImageTag(String dockerImageTag) {
    this.dockerImageTag = dockerImageTag;
    return this;
  }

  /**
   *
   * (Required)
   *
   */
  @JsonProperty("documentationUrl")
  public String getDocumentationUrl() {
    return documentationUrl;
  }

  /**
   *
   * (Required)
   *
   */
  @JsonProperty("documentationUrl")
  public void setDocumentationUrl(String documentationUrl) {
    this.documentationUrl = documentationUrl;
  }

  public ConnectorRegistryDestinationDefinition withDocumentationUrl(String documentationUrl) {
    this.documentationUrl = documentationUrl;
    return this;
  }

  @JsonProperty("icon")
  public String getIcon() {
    return icon;
  }

  @JsonProperty("icon")
  public void setIcon(String icon) {
    this.icon = icon;
  }

  public ConnectorRegistryDestinationDefinition withIcon(String icon) {
    this.icon = icon;
    return this;
  }

  @JsonProperty("iconUrl")
  public String getIconUrl() {
    return iconUrl;
  }

  @JsonProperty("iconUrl")
  public void setIconUrl(String iconUrl) {
    this.iconUrl = iconUrl;
  }

  public ConnectorRegistryDestinationDefinition withIconUrl(String iconUrl) {
    this.iconUrl = iconUrl;
    return this;
  }

  /**
   *
   * (Required)
   *
   */
  @JsonProperty("spec")
  public ConnectorSpecification getSpec() {
    return spec;
  }

  /**
   *
   * (Required)
   *
   */
  @JsonProperty("spec")
  public void setSpec(ConnectorSpecification spec) {
    this.spec = spec;
  }

  public ConnectorRegistryDestinationDefinition withSpec(ConnectorSpecification spec) {
    this.spec = spec;
    return this;
  }

  /**
   * if false, the configuration is active. if true, then this configuration is permanently off.
   *
   */
  @JsonProperty("tombstone")
  public Boolean getTombstone() {
    return tombstone;
  }

  /**
   * if false, the configuration is active. if true, then this configuration is permanently off.
   *
   */
  @JsonProperty("tombstone")
  public void setTombstone(Boolean tombstone) {
    this.tombstone = tombstone;
  }

  public ConnectorRegistryDestinationDefinition withTombstone(Boolean tombstone) {
    this.tombstone = tombstone;
    return this;
  }

  /**
   * true if this connector definition is available to all workspaces
   *
   */
  @JsonProperty("public")
  public Boolean getPublic() {
    return _public;
  }

  /**
   * true if this connector definition is available to all workspaces
   *
   */
  @JsonProperty("public")
  public void setPublic(Boolean _public) {
    this._public = _public;
  }

  public ConnectorRegistryDestinationDefinition withPublic(Boolean _public) {
    this._public = _public;
    return this;
  }

  /**
   * whether this is a custom connector definition
   *
   */
  @JsonProperty("custom")
  public Boolean getCustom() {
    return custom;
  }

  /**
   * whether this is a custom connector definition
   *
   */
  @JsonProperty("custom")
  public void setCustom(Boolean custom) {
    this.custom = custom;
  }

  public ConnectorRegistryDestinationDefinition withCustom(Boolean custom) {
    this.custom = custom;
    return this;
  }

  /**
   * The level of support provided by Airbyte for this connector.
   *
   */
  @JsonProperty("supportLevel")
  public SupportLevel getSupportLevel() {
    return supportLevel;
  }

  /**
   * The level of support provided by Airbyte for this connector.
   *
   */
  @JsonProperty("supportLevel")
  public void setSupportLevel(SupportLevel supportLevel) {
    this.supportLevel = supportLevel;
  }

  public ConnectorRegistryDestinationDefinition withSupportLevel(SupportLevel supportLevel) {
    this.supportLevel = supportLevel;
    return this;
  }

  /**
   * Deprecated. Use supportLevel instead.
   *
   */
  @JsonProperty("releaseStage")
  public ReleaseStage getReleaseStage() {
    return releaseStage;
  }

  /**
   * Deprecated. Use supportLevel instead.
   *
   */
  @JsonProperty("releaseStage")
  public void setReleaseStage(ReleaseStage releaseStage) {
    this.releaseStage = releaseStage;
  }

  public ConnectorRegistryDestinationDefinition withReleaseStage(ReleaseStage releaseStage) {
    this.releaseStage = releaseStage;
    return this;
  }

  /**
   * The date when this connector was first released, in yyyy-mm-dd format.
   *
   */
  @JsonProperty("releaseDate")
  public String getReleaseDate() {
    return releaseDate;
  }

  /**
   * The date when this connector was first released, in yyyy-mm-dd format.
   *
   */
  @JsonProperty("releaseDate")
  public void setReleaseDate(String releaseDate) {
    this.releaseDate = releaseDate;
  }

  public ConnectorRegistryDestinationDefinition withReleaseDate(String releaseDate) {
    this.releaseDate = releaseDate;
    return this;
  }

  /**
   * ScopedResourceRequirements
   * <p>
   * actor or actor definition specific resource requirements
   *
   */
  @JsonProperty("resourceRequirements")
  public ScopedResourceRequirements getResourceRequirements() {
    return resourceRequirements;
  }

  /**
   * ScopedResourceRequirements
   * <p>
   * actor or actor definition specific resource requirements
   *
   */
  @JsonProperty("resourceRequirements")
  public void setResourceRequirements(ScopedResourceRequirements resourceRequirements) {
    this.resourceRequirements = resourceRequirements;
  }

  public ConnectorRegistryDestinationDefinition withResourceRequirements(ScopedResourceRequirements resourceRequirements) {
    this.resourceRequirements = resourceRequirements;
    return this;
  }

  /**
   * the Airbyte Protocol version supported by the connector
   *
   */
  @JsonProperty("protocolVersion")
  public String getProtocolVersion() {
    return protocolVersion;
  }

  /**
   * the Airbyte Protocol version supported by the connector
   *
   */
  @JsonProperty("protocolVersion")
  public void setProtocolVersion(String protocolVersion) {
    this.protocolVersion = protocolVersion;
  }

  public ConnectorRegistryDestinationDefinition withProtocolVersion(String protocolVersion) {
    this.protocolVersion = protocolVersion;
    return this;
  }

  /**
   * AllowedHosts
   * <p>
   * A connector's allowed hosts. If present, the platform will limit communication to only hosts
   * which are listed in `AllowedHosts.hosts`.
   *
   */
  @JsonProperty("allowedHosts")
  public AllowedHosts getAllowedHosts() {
    return allowedHosts;
  }

  /**
   * AllowedHosts
   * <p>
   * A connector's allowed hosts. If present, the platform will limit communication to only hosts
   * which are listed in `AllowedHosts.hosts`.
   *
   */
  @JsonProperty("allowedHosts")
  public void setAllowedHosts(AllowedHosts allowedHosts) {
    this.allowedHosts = allowedHosts;
  }

  public ConnectorRegistryDestinationDefinition withAllowedHosts(AllowedHosts allowedHosts) {
    this.allowedHosts = allowedHosts;
    return this;
  }

  /**
   * ConnectorReleasesDestination
   * <p>
   * Releases for a destination connector.
   *
   */
  @JsonProperty("releases")
  public ConnectorReleasesDestination getReleases() {
    return releases;
  }

  /**
   * ConnectorReleasesDestination
   * <p>
   * Releases for a destination connector.
   *
   */
  @JsonProperty("releases")
  public void setReleases(ConnectorReleasesDestination releases) {
    this.releases = releases;
  }

  public ConnectorRegistryDestinationDefinition withReleases(ConnectorReleasesDestination releases) {
    this.releases = releases;
    return this;
  }

  /**
   * an optional flag indicating whether the refresh operation is available for this destination.
   *
   */
  @JsonProperty("supportsRefreshes")
  public Boolean getSupportsRefreshes() {
    return supportsRefreshes;
  }

  /**
   * an optional flag indicating whether the refresh operation is available for this destination.
   *
   */
  @JsonProperty("supportsRefreshes")
  public void setSupportsRefreshes(Boolean supportsRefreshes) {
    this.supportsRefreshes = supportsRefreshes;
  }

  public ConnectorRegistryDestinationDefinition withSupportsRefreshes(Boolean supportsRefreshes) {
    this.supportsRefreshes = supportsRefreshes;
    return this;
  }

  /**
   * ConnectorRegistryEntryGeneratedFields
   * <p>
   * Optional schema for fields generated as metadata is processed
   *
   */
  @JsonProperty("generated")
  public ConnectorRegistryEntryGeneratedFields getGenerated() {
    return generated;
  }

  /**
   * ConnectorRegistryEntryGeneratedFields
   * <p>
   * Optional schema for fields generated as metadata is processed
   *
   */
  @JsonProperty("generated")
  public void setGenerated(ConnectorRegistryEntryGeneratedFields generated) {
    this.generated = generated;
  }

  public ConnectorRegistryDestinationDefinition withGenerated(ConnectorRegistryEntryGeneratedFields generated) {
    this.generated = generated;
    return this;
  }

  /**
   * ConnectorPackageInfo
   * <p>
   * Information about the contents of the connector image
   *
   */
  @JsonProperty("packageInfo")
  public ConnectorPackageInfo getPackageInfo() {
    return packageInfo;
  }

  /**
   * ConnectorPackageInfo
   * <p>
   * Information about the contents of the connector image
   *
   */
  @JsonProperty("packageInfo")
  public void setPackageInfo(ConnectorPackageInfo packageInfo) {
    this.packageInfo = packageInfo;
  }

  public ConnectorRegistryDestinationDefinition withPackageInfo(ConnectorPackageInfo packageInfo) {
    this.packageInfo = packageInfo;
    return this;
  }

  /**
   * AbInternal
   * <p>
   * object that describes Airbyte internal fields
   *
   */
  @JsonProperty("ab_internal")
  public AbInternal getAbInternal() {
    return abInternal;
  }

  /**
   * AbInternal
   * <p>
   * object that describes Airbyte internal fields
   *
   */
  @JsonProperty("ab_internal")
  public void setAbInternal(AbInternal abInternal) {
    this.abInternal = abInternal;
  }

  public ConnectorRegistryDestinationDefinition withAbInternal(AbInternal abInternal) {
    this.abInternal = abInternal;
    return this;
  }

  /**
   * The language that the connector is written in.
   *
   */
  @JsonProperty("language")
  public String getLanguage() {
    return language;
  }

  /**
   * The language that the connector is written in.
   *
   */
  @JsonProperty("language")
  public void setLanguage(String language) {
    this.language = language;
  }

  public ConnectorRegistryDestinationDefinition withLanguage(String language) {
    this.language = language;
    return this;
  }

  /**
   * flag indicating whether the file transfer mode is available for this destination.
   *
   */
  @JsonProperty("supportsFileTransfer")
  public Boolean getSupportsFileTransfer() {
    return supportsFileTransfer;
  }

  /**
   * flag indicating whether the file transfer mode is available for this destination.
   *
   */
  @JsonProperty("supportsFileTransfer")
  public void setSupportsFileTransfer(Boolean supportsFileTransfer) {
    this.supportsFileTransfer = supportsFileTransfer;
  }

  public ConnectorRegistryDestinationDefinition withSupportsFileTransfer(Boolean supportsFileTransfer) {
    this.supportsFileTransfer = supportsFileTransfer;
    return this;
  }

  /**
   * flag indicating whether the connection configuration should align with the data activation
   * paradigm.
   *
   */
  @JsonProperty("supportsDataActivation")
  public Boolean getSupportsDataActivation() {
    return supportsDataActivation;
  }

  /**
   * flag indicating whether the connection configuration should align with the data activation
   * paradigm.
   *
   */
  @JsonProperty("supportsDataActivation")
  public void setSupportsDataActivation(Boolean supportsDataActivation) {
    this.supportsDataActivation = supportsDataActivation;
  }

  public ConnectorRegistryDestinationDefinition withSupportsDataActivation(Boolean supportsDataActivation) {
    this.supportsDataActivation = supportsDataActivation;
    return this;
  }

  /**
   * config containing information about connector sync architecture
   *
   */
  @JsonProperty("connectorIPCOptions")
  public JsonNode getConnectorIPCOptions() {
    return connectorIPCOptions;
  }

  /**
   * config containing information about connector sync architecture
   *
   */
  @JsonProperty("connectorIPCOptions")
  public void setConnectorIPCOptions(JsonNode connectorIPCOptions) {
    this.connectorIPCOptions = connectorIPCOptions;
  }

  public ConnectorRegistryDestinationDefinition withConnectorIPCOptions(JsonNode connectorIPCOptions) {
    this.connectorIPCOptions = connectorIPCOptions;
    return this;
  }

  @JsonAnyGetter
  public Map<String, Object> getAdditionalProperties() {
    return this.additionalProperties;
  }

  @JsonAnySetter
  public void setAdditionalProperty(String name, Object value) {
    this.additionalProperties.put(name, value);
  }

  public ConnectorRegistryDestinationDefinition withAdditionalProperty(String name, Object value) {
    this.additionalProperties.put(name, value);
    return this;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append(ConnectorRegistryDestinationDefinition.class.getName()).append('@').append(Integer.toHexString(System.identityHashCode(this)))
        .append('[');
    sb.append("destinationDefinitionId");
    sb.append('=');
    sb.append(((this.destinationDefinitionId == null) ? "<null>" : this.destinationDefinitionId));
    sb.append(',');
    sb.append("name");
    sb.append('=');
    sb.append(((this.name == null) ? "<null>" : this.name));
    sb.append(',');
    sb.append("dockerRepository");
    sb.append('=');
    sb.append(((this.dockerRepository == null) ? "<null>" : this.dockerRepository));
    sb.append(',');
    sb.append("dockerImageTag");
    sb.append('=');
    sb.append(((this.dockerImageTag == null) ? "<null>" : this.dockerImageTag));
    sb.append(',');
    sb.append("documentationUrl");
    sb.append('=');
    sb.append(((this.documentationUrl == null) ? "<null>" : this.documentationUrl));
    sb.append(',');
    sb.append("icon");
    sb.append('=');
    sb.append(((this.icon == null) ? "<null>" : this.icon));
    sb.append(',');
    sb.append("iconUrl");
    sb.append('=');
    sb.append(((this.iconUrl == null) ? "<null>" : this.iconUrl));
    sb.append(',');
    sb.append("spec");
    sb.append('=');
    sb.append(((this.spec == null) ? "<null>" : this.spec));
    sb.append(',');
    sb.append("tombstone");
    sb.append('=');
    sb.append(((this.tombstone == null) ? "<null>" : this.tombstone));
    sb.append(',');
    sb.append("_public");
    sb.append('=');
    sb.append(((this._public == null) ? "<null>" : this._public));
    sb.append(',');
    sb.append("custom");
    sb.append('=');
    sb.append(((this.custom == null) ? "<null>" : this.custom));
    sb.append(',');
    sb.append("supportLevel");
    sb.append('=');
    sb.append(((this.supportLevel == null) ? "<null>" : this.supportLevel));
    sb.append(',');
    sb.append("releaseStage");
    sb.append('=');
    sb.append(((this.releaseStage == null) ? "<null>" : this.releaseStage));
    sb.append(',');
    sb.append("releaseDate");
    sb.append('=');
    sb.append(((this.releaseDate == null) ? "<null>" : this.releaseDate));
    sb.append(',');
    sb.append("resourceRequirements");
    sb.append('=');
    sb.append(((this.resourceRequirements == null) ? "<null>" : this.resourceRequirements));
    sb.append(',');
    sb.append("protocolVersion");
    sb.append('=');
    sb.append(((this.protocolVersion == null) ? "<null>" : this.protocolVersion));
    sb.append(',');
    sb.append("allowedHosts");
    sb.append('=');
    sb.append(((this.allowedHosts == null) ? "<null>" : this.allowedHosts));
    sb.append(',');
    sb.append("releases");
    sb.append('=');
    sb.append(((this.releases == null) ? "<null>" : this.releases));
    sb.append(',');
    sb.append("supportsRefreshes");
    sb.append('=');
    sb.append(((this.supportsRefreshes == null) ? "<null>" : this.supportsRefreshes));
    sb.append(',');
    sb.append("generated");
    sb.append('=');
    sb.append(((this.generated == null) ? "<null>" : this.generated));
    sb.append(',');
    sb.append("packageInfo");
    sb.append('=');
    sb.append(((this.packageInfo == null) ? "<null>" : this.packageInfo));
    sb.append(',');
    sb.append("abInternal");
    sb.append('=');
    sb.append(((this.abInternal == null) ? "<null>" : this.abInternal));
    sb.append(',');
    sb.append("language");
    sb.append('=');
    sb.append(((this.language == null) ? "<null>" : this.language));
    sb.append(',');
    sb.append("supportsFileTransfer");
    sb.append('=');
    sb.append(((this.supportsFileTransfer == null) ? "<null>" : this.supportsFileTransfer));
    sb.append(',');
    sb.append("supportsDataActivation");
    sb.append('=');
    sb.append(((this.supportsDataActivation == null) ? "<null>" : this.supportsDataActivation));
    sb.append(',');
    sb.append("connectorIPCOptions");
    sb.append('=');
    sb.append(((this.connectorIPCOptions == null) ? "<null>" : this.connectorIPCOptions));
    sb.append(',');
    sb.append("additionalProperties");
    sb.append('=');
    sb.append(((this.additionalProperties == null) ? "<null>" : this.additionalProperties));
    sb.append(',');
    if (sb.charAt((sb.length() - 1)) == ',') {
      sb.setCharAt((sb.length() - 1), ']');
    } else {
      sb.append(']');
    }
    return sb.toString();
  }

  @Override
  public int hashCode() {
    int result = 1;
    result = ((result * 31) + ((this.allowedHosts == null) ? 0 : this.allowedHosts.hashCode()));
    result = ((result * 31) + ((this.documentationUrl == null) ? 0 : this.documentationUrl.hashCode()));
    result = ((result * 31) + ((this.releaseStage == null) ? 0 : this.releaseStage.hashCode()));
    result = ((result * 31) + ((this.icon == null) ? 0 : this.icon.hashCode()));
    result = ((result * 31) + ((this.language == null) ? 0 : this.language.hashCode()));
    result = ((result * 31) + ((this.spec == null) ? 0 : this.spec.hashCode()));
    result = ((result * 31) + ((this.supportsDataActivation == null) ? 0 : this.supportsDataActivation.hashCode()));
    result = ((result * 31) + ((this.generated == null) ? 0 : this.generated.hashCode()));
    result = ((result * 31) + ((this.protocolVersion == null) ? 0 : this.protocolVersion.hashCode()));
    result = ((result * 31) + ((this.iconUrl == null) ? 0 : this.iconUrl.hashCode()));
    result = ((result * 31) + ((this.abInternal == null) ? 0 : this.abInternal.hashCode()));
    result = ((result * 31) + ((this.tombstone == null) ? 0 : this.tombstone.hashCode()));
    result = ((result * 31) + ((this._public == null) ? 0 : this._public.hashCode()));
    result = ((result * 31) + ((this.releaseDate == null) ? 0 : this.releaseDate.hashCode()));
    result = ((result * 31) + ((this.dockerRepository == null) ? 0 : this.dockerRepository.hashCode()));
    result = ((result * 31) + ((this.custom == null) ? 0 : this.custom.hashCode()));
    result = ((result * 31) + ((this.supportLevel == null) ? 0 : this.supportLevel.hashCode()));
    result = ((result * 31) + ((this.connectorIPCOptions == null) ? 0 : this.connectorIPCOptions.hashCode()));
    result = ((result * 31) + ((this.releases == null) ? 0 : this.releases.hashCode()));
    result = ((result * 31) + ((this.resourceRequirements == null) ? 0 : this.resourceRequirements.hashCode()));
    result = ((result * 31) + ((this.supportsRefreshes == null) ? 0 : this.supportsRefreshes.hashCode()));
    result = ((result * 31) + ((this.dockerImageTag == null) ? 0 : this.dockerImageTag.hashCode()));
    result = ((result * 31) + ((this.name == null) ? 0 : this.name.hashCode()));
    result = ((result * 31) + ((this.destinationDefinitionId == null) ? 0 : this.destinationDefinitionId.hashCode()));
    result = ((result * 31) + ((this.additionalProperties == null) ? 0 : this.additionalProperties.hashCode()));
    result = ((result * 31) + ((this.packageInfo == null) ? 0 : this.packageInfo.hashCode()));
    result = ((result * 31) + ((this.supportsFileTransfer == null) ? 0 : this.supportsFileTransfer.hashCode()));
    return result;
  }

  @Override
  public boolean equals(Object other) {
    if (other == this) {
      return true;
    }
    if ((other instanceof ConnectorRegistryDestinationDefinition) == false) {
      return false;
    }
    ConnectorRegistryDestinationDefinition rhs = ((ConnectorRegistryDestinationDefinition) other);
    return ((((((((((((((((((((((((((((this.allowedHosts == rhs.allowedHosts)
        || ((this.allowedHosts != null) && this.allowedHosts.equals(rhs.allowedHosts)))
        && ((this.documentationUrl == rhs.documentationUrl)
            || ((this.documentationUrl != null) && this.documentationUrl.equals(rhs.documentationUrl))))
        && ((this.releaseStage == rhs.releaseStage) || ((this.releaseStage != null) && this.releaseStage.equals(rhs.releaseStage))))
        && ((this.icon == rhs.icon) || ((this.icon != null) && this.icon.equals(rhs.icon))))
        && ((this.language == rhs.language) || ((this.language != null) && this.language.equals(rhs.language))))
        && ((this.spec == rhs.spec) || ((this.spec != null) && this.spec.equals(rhs.spec))))
        && ((this.supportsDataActivation == rhs.supportsDataActivation)
            || ((this.supportsDataActivation != null) && this.supportsDataActivation.equals(rhs.supportsDataActivation))))
        && ((this.generated == rhs.generated) || ((this.generated != null) && this.generated.equals(rhs.generated))))
        && ((this.protocolVersion == rhs.protocolVersion) || ((this.protocolVersion != null) && this.protocolVersion.equals(rhs.protocolVersion))))
        && ((this.iconUrl == rhs.iconUrl) || ((this.iconUrl != null) && this.iconUrl.equals(rhs.iconUrl))))
        && ((this.abInternal == rhs.abInternal) || ((this.abInternal != null) && this.abInternal.equals(rhs.abInternal))))
        && ((this.tombstone == rhs.tombstone) || ((this.tombstone != null) && this.tombstone.equals(rhs.tombstone))))
        && ((this._public == rhs._public) || ((this._public != null) && this._public.equals(rhs._public))))
        && ((this.releaseDate == rhs.releaseDate) || ((this.releaseDate != null) && this.releaseDate.equals(rhs.releaseDate))))
        && ((this.dockerRepository == rhs.dockerRepository)
            || ((this.dockerRepository != null) && this.dockerRepository.equals(rhs.dockerRepository))))
        && ((this.custom == rhs.custom) || ((this.custom != null) && this.custom.equals(rhs.custom))))
        && ((this.supportLevel == rhs.supportLevel) || ((this.supportLevel != null) && this.supportLevel.equals(rhs.supportLevel))))
        && ((this.connectorIPCOptions == rhs.connectorIPCOptions)
            || ((this.connectorIPCOptions != null) && this.connectorIPCOptions.equals(rhs.connectorIPCOptions))))
        && ((this.releases == rhs.releases) || ((this.releases != null) && this.releases.equals(rhs.releases))))
        && ((this.resourceRequirements == rhs.resourceRequirements)
            || ((this.resourceRequirements != null) && this.resourceRequirements.equals(rhs.resourceRequirements))))
        && ((this.supportsRefreshes == rhs.supportsRefreshes)
            || ((this.supportsRefreshes != null) && this.supportsRefreshes.equals(rhs.supportsRefreshes))))
        && ((this.dockerImageTag == rhs.dockerImageTag) || ((this.dockerImageTag != null) && this.dockerImageTag.equals(rhs.dockerImageTag))))
        && ((this.name == rhs.name) || ((this.name != null) && this.name.equals(rhs.name))))
        && ((this.destinationDefinitionId == rhs.destinationDefinitionId)
            || ((this.destinationDefinitionId != null) && this.destinationDefinitionId.equals(rhs.destinationDefinitionId))))
        && ((this.additionalProperties == rhs.additionalProperties)
            || ((this.additionalProperties != null) && this.additionalProperties.equals(rhs.additionalProperties))))
        && ((this.packageInfo == rhs.packageInfo) || ((this.packageInfo != null) && this.packageInfo.equals(rhs.packageInfo))))
        && ((this.supportsFileTransfer == rhs.supportsFileTransfer)
            || ((this.supportsFileTransfer != null) && this.supportsFileTransfer.equals(rhs.supportsFileTransfer))));
  }

}
