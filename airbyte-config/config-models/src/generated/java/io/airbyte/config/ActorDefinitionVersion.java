/*
 * Copyright (c) 2020-2025 Airbyte, Inc., all rights reserved.
 */

package io.airbyte.config;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyDescription;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonValue;
import com.fasterxml.jackson.databind.JsonNode;
import io.airbyte.protocol.models.v0.ConnectorSpecification;
import jakarta.annotation.Generated;
import java.io.Serializable;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

/**
 * ActorDefinitionVersion
 * <p>
 * describes an actor definition version
 *
 */
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonPropertyOrder({
  "versionId",
  "actorDefinitionId",
  "dockerRepository",
  "dockerImageTag",
  "documentationUrl",
  "supportLevel",
  "releaseStage",
  "releaseDate",
  "spec",
  "protocolVersion",
  "allowedHosts",
  "suggestedStreams",
  "supportsRefreshes",
  "supportState",
  "lastPublished",
  "cdkVersion",
  "internalSupportLevel",
  "language",
  "supportsFileTransfer",
  "supportsDataActivation",
  "connectorIPCOptions"
})
@Generated(value = "Generated by jsonSchema2Pojo")
public class ActorDefinitionVersion implements Serializable {

  @JsonProperty("versionId")
  private UUID versionId;
  @JsonProperty("actorDefinitionId")
  private UUID actorDefinitionId;
  /**
   *
   * (Required)
   *
   */
  @JsonProperty("dockerRepository")
  private String dockerRepository;
  /**
   *
   * (Required)
   *
   */
  @JsonProperty("dockerImageTag")
  private String dockerImageTag;
  @JsonProperty("documentationUrl")
  private String documentationUrl;
  /**
   * The level of support provided by Airbyte for this connector.
   *
   */
  @JsonProperty("supportLevel")
  @JsonPropertyDescription("The level of support provided by Airbyte for this connector.")
  private SupportLevel supportLevel;
  /**
   * Deprecated. Use supportLevel instead.
   *
   */
  @JsonProperty("releaseStage")
  @JsonPropertyDescription("Deprecated. Use supportLevel instead.")
  private ReleaseStage releaseStage;
  /**
   * The date when this connector was first released, in yyyy-mm-dd format.
   *
   */
  @JsonProperty("releaseDate")
  @JsonPropertyDescription("The date when this connector was first released, in yyyy-mm-dd format.")
  private String releaseDate;
  /**
   *
   * (Required)
   *
   */
  @JsonProperty("spec")
  private ConnectorSpecification spec;
  /**
   * the Airbyte Protocol version supported by the connector
   *
   */
  @JsonProperty("protocolVersion")
  @JsonPropertyDescription("the Airbyte Protocol version supported by the connector")
  private String protocolVersion;
  /**
   * AllowedHosts
   * <p>
   * A connector's allowed hosts. If present, the platform will limit communication to only hosts
   * which are listed in `AllowedHosts.hosts`.
   *
   */
  @JsonProperty("allowedHosts")
  @JsonPropertyDescription("A connector's allowed hosts.  If present, the platform will limit communication to only hosts which are listed in `AllowedHosts.hosts`.")
  private AllowedHosts allowedHosts;
  /**
   * SuggestedStreams
   * <p>
   * A source's suggested streams. These will be suggested by default for new connections using this
   * source. Otherwise, all streams will be selected. This is useful for when your source has a lot of
   * streams, but the average user will only want a subset of them synced.
   *
   */
  @JsonProperty("suggestedStreams")
  @JsonPropertyDescription("A source's suggested streams.  These will be suggested by default for new connections using this source.  Otherwise, all streams will be selected.  This is useful for when your source has a lot of streams, but the average user will only want a subset of them synced.")
  private SuggestedStreams suggestedStreams;
  /**
   * an optional flag indicating whether a destination connector supports refreshes.
   *
   */
  @JsonProperty("supportsRefreshes")
  @JsonPropertyDescription("an optional flag indicating whether a destination connector supports refreshes.")
  private Boolean supportsRefreshes = false;
  /**
   * SupportState
   * <p>
   * enum that describes the support state of actor definition versions.
   *
   * supported: there are no version-forward breaking changes. deprecated: there are version-forward
   * breaking changes for which the upgradeDeadline is in the future. unsupported: there are
   * version-forward breaking changes for which the upgradeDeadline is in the past.
   *
   *
   */
  @JsonProperty("supportState")
  @JsonPropertyDescription("enum that describes the support state of actor definition versions.\n\nsupported: there are no version-forward breaking changes.\ndeprecated: there are version-forward breaking changes for which the upgradeDeadline is in the future.\nunsupported: there are version-forward breaking changes for which the upgradeDeadline is in the past.\n")
  private SupportState supportState = SupportState.fromValue("supported");
  /**
   * The time the connector was modified in the codebase.
   *
   */
  @JsonProperty("lastPublished")
  @JsonPropertyDescription("The time the connector was modified in the codebase.")
  private Date lastPublished;
  /**
   * The version of the CDK that the connector was built with. e.g. python:0.1.0, java:0.1.0
   *
   */
  @JsonProperty("cdkVersion")
  @JsonPropertyDescription("The version of the CDK that the connector was built with. e.g. python:0.1.0, java:0.1.0")
  private String cdkVersion;
  /**
   * Support level that we use for alerting
   *
   */
  @JsonProperty("internalSupportLevel")
  @JsonPropertyDescription("Support level that we use for alerting")
  private Long internalSupportLevel;
  /**
   * The language that the connector is written in.
   *
   */
  @JsonProperty("language")
  @JsonPropertyDescription("The language that the connector is written in.")
  private String language;
  /**
   * an optional flag indicating whether a destination connector supports file transfer.
   *
   */
  @JsonProperty("supportsFileTransfer")
  @JsonPropertyDescription("an optional flag indicating whether a destination connector supports file transfer.")
  private Boolean supportsFileTransfer = false;
  /**
   * an optional flag indicating whether a destination connector supports data activation.
   *
   */
  @JsonProperty("supportsDataActivation")
  @JsonPropertyDescription("an optional flag indicating whether a destination connector supports data activation.")
  private Boolean supportsDataActivation = false;
  /**
   * config containing information about connector sync architecture
   *
   */
  @JsonProperty("connectorIPCOptions")
  @JsonPropertyDescription("config containing information about connector sync architecture")
  private JsonNode connectorIPCOptions;
  @JsonIgnore
  private Map<String, Object> additionalProperties = new HashMap<String, Object>();
  private final static long serialVersionUID = 1537597838274720473L;

  @JsonProperty("versionId")
  public UUID getVersionId() {
    return versionId;
  }

  @JsonProperty("versionId")
  public void setVersionId(UUID versionId) {
    this.versionId = versionId;
  }

  public ActorDefinitionVersion withVersionId(UUID versionId) {
    this.versionId = versionId;
    return this;
  }

  @JsonProperty("actorDefinitionId")
  public UUID getActorDefinitionId() {
    return actorDefinitionId;
  }

  @JsonProperty("actorDefinitionId")
  public void setActorDefinitionId(UUID actorDefinitionId) {
    this.actorDefinitionId = actorDefinitionId;
  }

  public ActorDefinitionVersion withActorDefinitionId(UUID actorDefinitionId) {
    this.actorDefinitionId = actorDefinitionId;
    return this;
  }

  /**
   *
   * (Required)
   *
   */
  @JsonProperty("dockerRepository")
  public String getDockerRepository() {
    return dockerRepository;
  }

  /**
   *
   * (Required)
   *
   */
  @JsonProperty("dockerRepository")
  public void setDockerRepository(String dockerRepository) {
    this.dockerRepository = dockerRepository;
  }

  public ActorDefinitionVersion withDockerRepository(String dockerRepository) {
    this.dockerRepository = dockerRepository;
    return this;
  }

  /**
   *
   * (Required)
   *
   */
  @JsonProperty("dockerImageTag")
  public String getDockerImageTag() {
    return dockerImageTag;
  }

  /**
   *
   * (Required)
   *
   */
  @JsonProperty("dockerImageTag")
  public void setDockerImageTag(String dockerImageTag) {
    this.dockerImageTag = dockerImageTag;
  }

  public ActorDefinitionVersion withDockerImageTag(String dockerImageTag) {
    this.dockerImageTag = dockerImageTag;
    return this;
  }

  @JsonProperty("documentationUrl")
  public String getDocumentationUrl() {
    return documentationUrl;
  }

  @JsonProperty("documentationUrl")
  public void setDocumentationUrl(String documentationUrl) {
    this.documentationUrl = documentationUrl;
  }

  public ActorDefinitionVersion withDocumentationUrl(String documentationUrl) {
    this.documentationUrl = documentationUrl;
    return this;
  }

  /**
   * The level of support provided by Airbyte for this connector.
   *
   */
  @JsonProperty("supportLevel")
  public SupportLevel getSupportLevel() {
    return supportLevel;
  }

  /**
   * The level of support provided by Airbyte for this connector.
   *
   */
  @JsonProperty("supportLevel")
  public void setSupportLevel(SupportLevel supportLevel) {
    this.supportLevel = supportLevel;
  }

  public ActorDefinitionVersion withSupportLevel(SupportLevel supportLevel) {
    this.supportLevel = supportLevel;
    return this;
  }

  /**
   * Deprecated. Use supportLevel instead.
   *
   */
  @JsonProperty("releaseStage")
  public ReleaseStage getReleaseStage() {
    return releaseStage;
  }

  /**
   * Deprecated. Use supportLevel instead.
   *
   */
  @JsonProperty("releaseStage")
  public void setReleaseStage(ReleaseStage releaseStage) {
    this.releaseStage = releaseStage;
  }

  public ActorDefinitionVersion withReleaseStage(ReleaseStage releaseStage) {
    this.releaseStage = releaseStage;
    return this;
  }

  /**
   * The date when this connector was first released, in yyyy-mm-dd format.
   *
   */
  @JsonProperty("releaseDate")
  public String getReleaseDate() {
    return releaseDate;
  }

  /**
   * The date when this connector was first released, in yyyy-mm-dd format.
   *
   */
  @JsonProperty("releaseDate")
  public void setReleaseDate(String releaseDate) {
    this.releaseDate = releaseDate;
  }

  public ActorDefinitionVersion withReleaseDate(String releaseDate) {
    this.releaseDate = releaseDate;
    return this;
  }

  /**
   *
   * (Required)
   *
   */
  @JsonProperty("spec")
  public ConnectorSpecification getSpec() {
    return spec;
  }

  /**
   *
   * (Required)
   *
   */
  @JsonProperty("spec")
  public void setSpec(ConnectorSpecification spec) {
    this.spec = spec;
  }

  public ActorDefinitionVersion withSpec(ConnectorSpecification spec) {
    this.spec = spec;
    return this;
  }

  /**
   * the Airbyte Protocol version supported by the connector
   *
   */
  @JsonProperty("protocolVersion")
  public String getProtocolVersion() {
    return protocolVersion;
  }

  /**
   * the Airbyte Protocol version supported by the connector
   *
   */
  @JsonProperty("protocolVersion")
  public void setProtocolVersion(String protocolVersion) {
    this.protocolVersion = protocolVersion;
  }

  public ActorDefinitionVersion withProtocolVersion(String protocolVersion) {
    this.protocolVersion = protocolVersion;
    return this;
  }

  /**
   * AllowedHosts
   * <p>
   * A connector's allowed hosts. If present, the platform will limit communication to only hosts
   * which are listed in `AllowedHosts.hosts`.
   *
   */
  @JsonProperty("allowedHosts")
  public AllowedHosts getAllowedHosts() {
    return allowedHosts;
  }

  /**
   * AllowedHosts
   * <p>
   * A connector's allowed hosts. If present, the platform will limit communication to only hosts
   * which are listed in `AllowedHosts.hosts`.
   *
   */
  @JsonProperty("allowedHosts")
  public void setAllowedHosts(AllowedHosts allowedHosts) {
    this.allowedHosts = allowedHosts;
  }

  public ActorDefinitionVersion withAllowedHosts(AllowedHosts allowedHosts) {
    this.allowedHosts = allowedHosts;
    return this;
  }

  /**
   * SuggestedStreams
   * <p>
   * A source's suggested streams. These will be suggested by default for new connections using this
   * source. Otherwise, all streams will be selected. This is useful for when your source has a lot of
   * streams, but the average user will only want a subset of them synced.
   *
   */
  @JsonProperty("suggestedStreams")
  public SuggestedStreams getSuggestedStreams() {
    return suggestedStreams;
  }

  /**
   * SuggestedStreams
   * <p>
   * A source's suggested streams. These will be suggested by default for new connections using this
   * source. Otherwise, all streams will be selected. This is useful for when your source has a lot of
   * streams, but the average user will only want a subset of them synced.
   *
   */
  @JsonProperty("suggestedStreams")
  public void setSuggestedStreams(SuggestedStreams suggestedStreams) {
    this.suggestedStreams = suggestedStreams;
  }

  public ActorDefinitionVersion withSuggestedStreams(SuggestedStreams suggestedStreams) {
    this.suggestedStreams = suggestedStreams;
    return this;
  }

  /**
   * an optional flag indicating whether a destination connector supports refreshes.
   *
   */
  @JsonProperty("supportsRefreshes")
  public Boolean getSupportsRefreshes() {
    return supportsRefreshes;
  }

  /**
   * an optional flag indicating whether a destination connector supports refreshes.
   *
   */
  @JsonProperty("supportsRefreshes")
  public void setSupportsRefreshes(Boolean supportsRefreshes) {
    this.supportsRefreshes = supportsRefreshes;
  }

  public ActorDefinitionVersion withSupportsRefreshes(Boolean supportsRefreshes) {
    this.supportsRefreshes = supportsRefreshes;
    return this;
  }

  /**
   * SupportState
   * <p>
   * enum that describes the support state of actor definition versions.
   *
   * supported: there are no version-forward breaking changes. deprecated: there are version-forward
   * breaking changes for which the upgradeDeadline is in the future. unsupported: there are
   * version-forward breaking changes for which the upgradeDeadline is in the past.
   *
   *
   */
  @JsonProperty("supportState")
  public SupportState getSupportState() {
    return supportState;
  }

  /**
   * SupportState
   * <p>
   * enum that describes the support state of actor definition versions.
   *
   * supported: there are no version-forward breaking changes. deprecated: there are version-forward
   * breaking changes for which the upgradeDeadline is in the future. unsupported: there are
   * version-forward breaking changes for which the upgradeDeadline is in the past.
   *
   *
   */
  @JsonProperty("supportState")
  public void setSupportState(SupportState supportState) {
    this.supportState = supportState;
  }

  public ActorDefinitionVersion withSupportState(SupportState supportState) {
    this.supportState = supportState;
    return this;
  }

  /**
   * The time the connector was modified in the codebase.
   *
   */
  @JsonProperty("lastPublished")
  public Date getLastPublished() {
    return lastPublished;
  }

  /**
   * The time the connector was modified in the codebase.
   *
   */
  @JsonProperty("lastPublished")
  public void setLastPublished(Date lastPublished) {
    this.lastPublished = lastPublished;
  }

  public ActorDefinitionVersion withLastPublished(Date lastPublished) {
    this.lastPublished = lastPublished;
    return this;
  }

  /**
   * The version of the CDK that the connector was built with. e.g. python:0.1.0, java:0.1.0
   *
   */
  @JsonProperty("cdkVersion")
  public String getCdkVersion() {
    return cdkVersion;
  }

  /**
   * The version of the CDK that the connector was built with. e.g. python:0.1.0, java:0.1.0
   *
   */
  @JsonProperty("cdkVersion")
  public void setCdkVersion(String cdkVersion) {
    this.cdkVersion = cdkVersion;
  }

  public ActorDefinitionVersion withCdkVersion(String cdkVersion) {
    this.cdkVersion = cdkVersion;
    return this;
  }

  /**
   * Support level that we use for alerting
   *
   */
  @JsonProperty("internalSupportLevel")
  public Long getInternalSupportLevel() {
    return internalSupportLevel;
  }

  /**
   * Support level that we use for alerting
   *
   */
  @JsonProperty("internalSupportLevel")
  public void setInternalSupportLevel(Long internalSupportLevel) {
    this.internalSupportLevel = internalSupportLevel;
  }

  public ActorDefinitionVersion withInternalSupportLevel(Long internalSupportLevel) {
    this.internalSupportLevel = internalSupportLevel;
    return this;
  }

  /**
   * The language that the connector is written in.
   *
   */
  @JsonProperty("language")
  public String getLanguage() {
    return language;
  }

  /**
   * The language that the connector is written in.
   *
   */
  @JsonProperty("language")
  public void setLanguage(String language) {
    this.language = language;
  }

  public ActorDefinitionVersion withLanguage(String language) {
    this.language = language;
    return this;
  }

  /**
   * an optional flag indicating whether a destination connector supports file transfer.
   *
   */
  @JsonProperty("supportsFileTransfer")
  public Boolean getSupportsFileTransfer() {
    return supportsFileTransfer;
  }

  /**
   * an optional flag indicating whether a destination connector supports file transfer.
   *
   */
  @JsonProperty("supportsFileTransfer")
  public void setSupportsFileTransfer(Boolean supportsFileTransfer) {
    this.supportsFileTransfer = supportsFileTransfer;
  }

  public ActorDefinitionVersion withSupportsFileTransfer(Boolean supportsFileTransfer) {
    this.supportsFileTransfer = supportsFileTransfer;
    return this;
  }

  /**
   * an optional flag indicating whether a destination connector supports data activation.
   *
   */
  @JsonProperty("supportsDataActivation")
  public Boolean getSupportsDataActivation() {
    return supportsDataActivation;
  }

  /**
   * an optional flag indicating whether a destination connector supports data activation.
   *
   */
  @JsonProperty("supportsDataActivation")
  public void setSupportsDataActivation(Boolean supportsDataActivation) {
    this.supportsDataActivation = supportsDataActivation;
  }

  public ActorDefinitionVersion withSupportsDataActivation(Boolean supportsDataActivation) {
    this.supportsDataActivation = supportsDataActivation;
    return this;
  }

  /**
   * config containing information about connector sync architecture
   *
   */
  @JsonProperty("connectorIPCOptions")
  public JsonNode getConnectorIPCOptions() {
    return connectorIPCOptions;
  }

  /**
   * config containing information about connector sync architecture
   *
   */
  @JsonProperty("connectorIPCOptions")
  public void setConnectorIPCOptions(JsonNode connectorIPCOptions) {
    this.connectorIPCOptions = connectorIPCOptions;
  }

  public ActorDefinitionVersion withConnectorIPCOptions(JsonNode connectorIPCOptions) {
    this.connectorIPCOptions = connectorIPCOptions;
    return this;
  }

  @JsonAnyGetter
  public Map<String, Object> getAdditionalProperties() {
    return this.additionalProperties;
  }

  @JsonAnySetter
  public void setAdditionalProperty(String name, Object value) {
    this.additionalProperties.put(name, value);
  }

  public ActorDefinitionVersion withAdditionalProperty(String name, Object value) {
    this.additionalProperties.put(name, value);
    return this;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append(ActorDefinitionVersion.class.getName()).append('@').append(Integer.toHexString(System.identityHashCode(this))).append('[');
    sb.append("versionId");
    sb.append('=');
    sb.append(((this.versionId == null) ? "<null>" : this.versionId));
    sb.append(',');
    sb.append("actorDefinitionId");
    sb.append('=');
    sb.append(((this.actorDefinitionId == null) ? "<null>" : this.actorDefinitionId));
    sb.append(',');
    sb.append("dockerRepository");
    sb.append('=');
    sb.append(((this.dockerRepository == null) ? "<null>" : this.dockerRepository));
    sb.append(',');
    sb.append("dockerImageTag");
    sb.append('=');
    sb.append(((this.dockerImageTag == null) ? "<null>" : this.dockerImageTag));
    sb.append(',');
    sb.append("documentationUrl");
    sb.append('=');
    sb.append(((this.documentationUrl == null) ? "<null>" : this.documentationUrl));
    sb.append(',');
    sb.append("supportLevel");
    sb.append('=');
    sb.append(((this.supportLevel == null) ? "<null>" : this.supportLevel));
    sb.append(',');
    sb.append("releaseStage");
    sb.append('=');
    sb.append(((this.releaseStage == null) ? "<null>" : this.releaseStage));
    sb.append(',');
    sb.append("releaseDate");
    sb.append('=');
    sb.append(((this.releaseDate == null) ? "<null>" : this.releaseDate));
    sb.append(',');
    sb.append("spec");
    sb.append('=');
    sb.append(((this.spec == null) ? "<null>" : this.spec));
    sb.append(',');
    sb.append("protocolVersion");
    sb.append('=');
    sb.append(((this.protocolVersion == null) ? "<null>" : this.protocolVersion));
    sb.append(',');
    sb.append("allowedHosts");
    sb.append('=');
    sb.append(((this.allowedHosts == null) ? "<null>" : this.allowedHosts));
    sb.append(',');
    sb.append("suggestedStreams");
    sb.append('=');
    sb.append(((this.suggestedStreams == null) ? "<null>" : this.suggestedStreams));
    sb.append(',');
    sb.append("supportsRefreshes");
    sb.append('=');
    sb.append(((this.supportsRefreshes == null) ? "<null>" : this.supportsRefreshes));
    sb.append(',');
    sb.append("supportState");
    sb.append('=');
    sb.append(((this.supportState == null) ? "<null>" : this.supportState));
    sb.append(',');
    sb.append("lastPublished");
    sb.append('=');
    sb.append(((this.lastPublished == null) ? "<null>" : this.lastPublished));
    sb.append(',');
    sb.append("cdkVersion");
    sb.append('=');
    sb.append(((this.cdkVersion == null) ? "<null>" : this.cdkVersion));
    sb.append(',');
    sb.append("internalSupportLevel");
    sb.append('=');
    sb.append(((this.internalSupportLevel == null) ? "<null>" : this.internalSupportLevel));
    sb.append(',');
    sb.append("language");
    sb.append('=');
    sb.append(((this.language == null) ? "<null>" : this.language));
    sb.append(',');
    sb.append("supportsFileTransfer");
    sb.append('=');
    sb.append(((this.supportsFileTransfer == null) ? "<null>" : this.supportsFileTransfer));
    sb.append(',');
    sb.append("supportsDataActivation");
    sb.append('=');
    sb.append(((this.supportsDataActivation == null) ? "<null>" : this.supportsDataActivation));
    sb.append(',');
    sb.append("connectorIPCOptions");
    sb.append('=');
    sb.append(((this.connectorIPCOptions == null) ? "<null>" : this.connectorIPCOptions));
    sb.append(',');
    sb.append("additionalProperties");
    sb.append('=');
    sb.append(((this.additionalProperties == null) ? "<null>" : this.additionalProperties));
    sb.append(',');
    if (sb.charAt((sb.length() - 1)) == ',') {
      sb.setCharAt((sb.length() - 1), ']');
    } else {
      sb.append(']');
    }
    return sb.toString();
  }

  @Override
  public int hashCode() {
    int result = 1;
    result = ((result * 31) + ((this.allowedHosts == null) ? 0 : this.allowedHosts.hashCode()));
    result = ((result * 31) + ((this.documentationUrl == null) ? 0 : this.documentationUrl.hashCode()));
    result = ((result * 31) + ((this.cdkVersion == null) ? 0 : this.cdkVersion.hashCode()));
    result = ((result * 31) + ((this.releaseDate == null) ? 0 : this.releaseDate.hashCode()));
    result = ((result * 31) + ((this.supportState == null) ? 0 : this.supportState.hashCode()));
    result = ((result * 31) + ((this.dockerRepository == null) ? 0 : this.dockerRepository.hashCode()));
    result = ((result * 31) + ((this.releaseStage == null) ? 0 : this.releaseStage.hashCode()));
    result = ((result * 31) + ((this.lastPublished == null) ? 0 : this.lastPublished.hashCode()));
    result = ((result * 31) + ((this.language == null) ? 0 : this.language.hashCode()));
    result = ((result * 31) + ((this.supportLevel == null) ? 0 : this.supportLevel.hashCode()));
    result = ((result * 31) + ((this.connectorIPCOptions == null) ? 0 : this.connectorIPCOptions.hashCode()));
    result = ((result * 31) + ((this.spec == null) ? 0 : this.spec.hashCode()));
    result = ((result * 31) + ((this.suggestedStreams == null) ? 0 : this.suggestedStreams.hashCode()));
    result = ((result * 31) + ((this.supportsRefreshes == null) ? 0 : this.supportsRefreshes.hashCode()));
    result = ((result * 31) + ((this.supportsDataActivation == null) ? 0 : this.supportsDataActivation.hashCode()));
    result = ((result * 31) + ((this.versionId == null) ? 0 : this.versionId.hashCode()));
    result = ((result * 31) + ((this.actorDefinitionId == null) ? 0 : this.actorDefinitionId.hashCode()));
    result = ((result * 31) + ((this.dockerImageTag == null) ? 0 : this.dockerImageTag.hashCode()));
    result = ((result * 31) + ((this.protocolVersion == null) ? 0 : this.protocolVersion.hashCode()));
    result = ((result * 31) + ((this.additionalProperties == null) ? 0 : this.additionalProperties.hashCode()));
    result = ((result * 31) + ((this.internalSupportLevel == null) ? 0 : this.internalSupportLevel.hashCode()));
    result = ((result * 31) + ((this.supportsFileTransfer == null) ? 0 : this.supportsFileTransfer.hashCode()));
    return result;
  }

  @Override
  public boolean equals(Object other) {
    if (other == this) {
      return true;
    }
    if ((other instanceof ActorDefinitionVersion) == false) {
      return false;
    }
    ActorDefinitionVersion rhs = ((ActorDefinitionVersion) other);
    return (((((((((((((((((((((((this.allowedHosts == rhs.allowedHosts)
        || ((this.allowedHosts != null) && this.allowedHosts.equals(rhs.allowedHosts)))
        && ((this.documentationUrl == rhs.documentationUrl)
            || ((this.documentationUrl != null) && this.documentationUrl.equals(rhs.documentationUrl))))
        && ((this.cdkVersion == rhs.cdkVersion) || ((this.cdkVersion != null) && this.cdkVersion.equals(rhs.cdkVersion))))
        && ((this.releaseDate == rhs.releaseDate) || ((this.releaseDate != null) && this.releaseDate.equals(rhs.releaseDate))))
        && ((this.supportState == rhs.supportState) || ((this.supportState != null) && this.supportState.equals(rhs.supportState))))
        && ((this.dockerRepository == rhs.dockerRepository)
            || ((this.dockerRepository != null) && this.dockerRepository.equals(rhs.dockerRepository))))
        && ((this.releaseStage == rhs.releaseStage) || ((this.releaseStage != null) && this.releaseStage.equals(rhs.releaseStage))))
        && ((this.lastPublished == rhs.lastPublished) || ((this.lastPublished != null) && this.lastPublished.equals(rhs.lastPublished))))
        && ((this.language == rhs.language) || ((this.language != null) && this.language.equals(rhs.language))))
        && ((this.supportLevel == rhs.supportLevel) || ((this.supportLevel != null) && this.supportLevel.equals(rhs.supportLevel))))
        && ((this.connectorIPCOptions == rhs.connectorIPCOptions)
            || ((this.connectorIPCOptions != null) && this.connectorIPCOptions.equals(rhs.connectorIPCOptions))))
        && ((this.spec == rhs.spec) || ((this.spec != null) && this.spec.equals(rhs.spec))))
        && ((this.suggestedStreams == rhs.suggestedStreams)
            || ((this.suggestedStreams != null) && this.suggestedStreams.equals(rhs.suggestedStreams))))
        && ((this.supportsRefreshes == rhs.supportsRefreshes)
            || ((this.supportsRefreshes != null) && this.supportsRefreshes.equals(rhs.supportsRefreshes))))
        && ((this.supportsDataActivation == rhs.supportsDataActivation)
            || ((this.supportsDataActivation != null) && this.supportsDataActivation.equals(rhs.supportsDataActivation))))
        && ((this.versionId == rhs.versionId) || ((this.versionId != null) && this.versionId.equals(rhs.versionId))))
        && ((this.actorDefinitionId == rhs.actorDefinitionId)
            || ((this.actorDefinitionId != null) && this.actorDefinitionId.equals(rhs.actorDefinitionId))))
        && ((this.dockerImageTag == rhs.dockerImageTag) || ((this.dockerImageTag != null) && this.dockerImageTag.equals(rhs.dockerImageTag))))
        && ((this.protocolVersion == rhs.protocolVersion) || ((this.protocolVersion != null) && this.protocolVersion.equals(rhs.protocolVersion))))
        && ((this.additionalProperties == rhs.additionalProperties)
            || ((this.additionalProperties != null) && this.additionalProperties.equals(rhs.additionalProperties))))
        && ((this.internalSupportLevel == rhs.internalSupportLevel)
            || ((this.internalSupportLevel != null) && this.internalSupportLevel.equals(rhs.internalSupportLevel))))
        && ((this.supportsFileTransfer == rhs.supportsFileTransfer)
            || ((this.supportsFileTransfer != null) && this.supportsFileTransfer.equals(rhs.supportsFileTransfer))));
  }

  /**
   * SupportState
   * <p>
   * enum that describes the support state of actor definition versions.
   *
   * supported: there are no version-forward breaking changes. deprecated: there are version-forward
   * breaking changes for which the upgradeDeadline is in the future. unsupported: there are
   * version-forward breaking changes for which the upgradeDeadline is in the past.
   *
   *
   */
  public enum SupportState {

    SUPPORTED("supported"),
    DEPRECATED("deprecated"),
    UNSUPPORTED("unsupported");

    private final String value;
    private final static Map<String, SupportState> CONSTANTS = new HashMap<String, SupportState>();

    static {
      for (SupportState c : values()) {
        CONSTANTS.put(c.value, c);
      }
    }

    private SupportState(String value) {
      this.value = value;
    }

    @Override
    public String toString() {
      return this.value;
    }

    @JsonValue
    public String value() {
      return this.value;
    }

    @JsonCreator
    public static SupportState fromValue(String value) {
      SupportState constant = CONSTANTS.get(value);
      if (constant == null) {
        throw new IllegalArgumentException(value);
      } else {
        return constant;
      }
    }

  }

}
